{"_pageInfo":{"numberOnPage":31,"total":31},"responseList":[{"frameworkId":9,"frameworkName":"Binary Lookup","frameworkType":"BYTE_BUFFER","description":"This Binary Lookup algorithm returns a replacement value provided from the list of lookupFiles uploaded:\n1. A hash is computed on the input and a replacement file is chosen for the hashed input\n2. If the input to the mask method is null, the output to the datasource will be null\n3. If the input to the mask method is an empty bytebuffer, the method will return the same object back to datasource\n4. A maximum of 50 replacement files can be used for this algorithm. If more than 50 files are attached to the algorithm, an exception will be thrown to the UI when the masking job runs","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":30,"frameworkName":"BR - Financial ID","frameworkType":"STRING","description":"Masks CPF and CNPJ Brazilian registry numbers and falls back to the chained algorithm for unexpected data.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":22,"frameworkName":"Character Mapping","frameworkType":"STRING","description":"This Character Mapping algorithm transforms text values by mapping each character to a value selected from the same character group. Characters not assigned to a character group are not masked. The masked result is deterministic for each input under the same algorithm key. As long as at least one character is maskable, the result will never be equal to the input. When applied to text data, a unique result is guaranteed for each unique input. Only characters that can be represented by a single UTF-16 code unit may be masked, which includes most characters used in modern languages.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":17,"frameworkName":"Character Replacement","frameworkType":"STRING","description":"Replaces characters in a string with other characters. Can be used to filter out characters from the input, output or both. Allows multiple replacement rules to be applied to the input string. Can remove accent characters from the input string before or after the chained algorithm masking. Chains to a String algorithm, and can ensure that input data is changed by it.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":37,"frameworkName":"CnpjMC","frameworkType":"GENERIC_DATA_ROW","description":"Algoritmo para mascaramento CM:Numeric de CNPJ armazenados em 3 colunas:raiz, matriz/filial, dígitos verificadores","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":43,"name":"inscricao","type":"STRING","isReadOnly":false,"isOptional":false},{"fieldId":44,"name":"matrizFilial","type":"STRING","isReadOnly":false,"isOptional":false},{"fieldId":45,"name":"digitos","type":"STRING","isReadOnly":false,"isOptional":false}]},{"frameworkId":34,"frameworkName":"CpfCnpj","frameworkType":"STRING","description":"Algoritmo para mascaramento CM:Numeric de CPF ou CNPJ armazenados em colunas únicas","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":36,"frameworkName":"CpfMC","frameworkType":"GENERIC_DATA_ROW","description":"Algoritmo para mascaramento CM:Numeric de CPF armazenados em 2 colunas:raiz, dígitos verificadores","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":41,"name":"inscricao","type":"STRING","isReadOnly":false,"isOptional":false},{"fieldId":42,"name":"digitos","type":"STRING","isReadOnly":false,"isOptional":false}]},{"frameworkId":19,"frameworkName":"Data Cleansing","frameworkType":"STRING","description":"The Data Cleansing algorithm is used to standardize varied spellings, misspellings, and abbreviations for the same name. It uses a lookup file with mappings of value to replacement pairs. For example, \"Ariz\", \"Az\", and \"Arizona\" can all be cleansed to \"AZ\". Use this algorithm if the target data needs to be in a standard format prior to masking.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":3,"frameworkName":"Date Replacement","frameworkType":"LOCAL_DATE_TIME","description":"This Date Replacement algorithm masks LocalDateTime values based on the specified minimum and maximum dates given for the range as well as the unit of time. The masked result is deterministic for each input with the same algorithm key and date range. The granularity of the masked date is determined by the unit of time specified.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":13,"frameworkName":"Date Shift","frameworkType":"LOCAL_DATE_TIME","description":"This Date Shift algorithm masks LocalDateTime values based on the specified range values, unit of time, and whether or not the unit of time should roll. The masked result is deterministic for each input with the same algorithm key and date range. The algorithm does not allow for zero mask so all masked values will never be equal to the input.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":38,"frameworkName":"DDD","frameworkType":"STRING","description":"Algoritmo para mascaramento CM:Numeric para DDDs armazenados em colunas únicas","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":10,"frameworkName":"Dependent Date Shift","frameworkType":"GENERIC_DATA_ROW","description":"This Dependent Date Shift algorithm takes in 2 dates (designated date1 and date2). It masks date1 based on the provided values for minRange, maxRange, unit and roll. It then modifies the original interval based on intervalRange and unit to calculate date2. If the dates differ but the returned interval is zero (i.e.: the difference between the dates is smaller than the interval value), we assume the interval value to be 1 if date2 is later than date1 and -1 if date1 is later than date2. The masked results are deterministic for each pair of inputs with the same algorithm key and date and interval ranges. The algorithm does not allow for zero mask so all masked values will never be equal to the input. If date1 is not provided, date2 will be masked based on the provided values for minRange, maxRange, unit and roll.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":18,"name":"date1","type":"LOCAL_DATE_TIME","isReadOnly":false,"isOptional":false,"description":"The first date to shift"},{"fieldId":19,"name":"date2","type":"LOCAL_DATE_TIME","isReadOnly":false,"isOptional":false,"description":"The second date to shift"}]},{"frameworkId":14,"frameworkName":"Email","frameworkType":"STRING","description":"This Email algorithm masks the name and domain portions of emails separately. For each portion, the masking is based on the action specified. Any input without an \"@\" symbol will be masked by the specified nameAction.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":6,"frameworkName":"Free Text Redaction","frameworkType":"STRING","description":"Free Text Redaction algorithm redacts sensitive data that appears in free-text columns. The algorithm uses a list of regular expressions and/or a lookup file to match and to redact the input data. The algorithm can be used in one of two modes: denyList or allowList. The denyList mode redacts input data matched with the provided regular expressions and/or lookup file entries. The allowList mode keeps the input data matched with the provided regular expressions or lookup file entries. As the result, only matched input entries remain visible. The maximum number of supported regular expressions is 50. The maximum number of entries in the lookup file is 1000.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":12,"frameworkName":"FullName","frameworkType":"STRING","description":"This FullName algorithm masks input full name, delegating the masking of the first name(s)\nand last name to corresponding chained Name algorithms.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":29,"frameworkName":"IBAN","frameworkType":"STRING","description":"This IBAN algorithm preserves country code, masks account and bank information and generates a new check number. A configurable amount of digits betweeen 6 and 36 can be masked. Validation of the input and masking produced IBAN can be configured for custom instances of the algorithm.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":5,"frameworkName":"Mapping","frameworkType":"STRING","description":"The Mapping Algorithm will provide a 1-to-1 mapping between a given user input and a mapping value from a list provided by the user. Once mappings are established they are reused whenever the algorithm is run.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":11,"frameworkName":"MinMax Date","frameworkType":"LOCAL_DATE_TIME","description":"The MinMax Date algorithm normalizes data within a range specified by the minDate and maxDate values.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":25,"frameworkName":"MinMax Number","frameworkType":"BIG_DECIMAL","description":"The MinMax algorithm framework normalizes data within a range specified by the minValue and maxValue.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":4,"frameworkName":"Multi Column Address","frameworkType":"GENERIC_DATA_ROW","description":"The framework Multi Column Address is a multi column address masking algorithm\nand requires a delimited file (CSV) with the documented field sequence.\nOne line of CSV = one address > using Secure Lookup for deterministic matching.\nYou can (optionally) configure any \"AddressGroups\" with a \"matchList\". The values are based on the configured matchingColumn values. \nThe addressGrouping allows to provide specific values from CSV based on the matchingColumn value in input; Both data to mask and CSV must contain the selected matchingColumn as column, the matching between column value and group is configured in matchList which is part of the group config.\nIf addressGroup A has matchList=1,2,3 and input record matchingColumn has value 1 > the result can be any record belonging to matchingColumn value 1, 2 or 3.\nIf the matchingColumn row value does not exist in any addressGroup the row is assigned to the fallbackGroup.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":1,"name":"CITY","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional column CITY"},{"fieldId":2,"name":"STREET","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional column STREET"},{"fieldId":3,"name":"ZIP","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional column ZIP"},{"fieldId":4,"name":"HOUSE_NO","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional column HOUSE_NO"},{"fieldId":5,"name":"STREET_HOUSE_NO","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional STREET and HOUSE_NO"},{"fieldId":6,"name":"REGION","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional REGION"},{"fieldId":7,"name":"COUNTRY","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional COUNTRY"},{"fieldId":8,"name":"COUNTRY_CODE","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional COUNTRY_CODE"},{"fieldId":9,"name":"LONGITUDE","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional LONGITUDE"},{"fieldId":10,"name":"LATITUDE","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional LATITUDE"},{"fieldId":11,"name":"OFFICE","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional OFFICE"},{"fieldId":12,"name":"ADDRESS","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete ADDRESS"},{"fieldId":13,"name":"ADDRESS_LINE1","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete ADDRESS_LINE1"},{"fieldId":14,"name":"ADDRESS_LINE2","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete ADDRESS_LINE2"},{"fieldId":15,"name":"OPTION1","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete OPTION1"},{"fieldId":16,"name":"OPTION2","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete OPTION2"},{"fieldId":17,"name":"OPTION3","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Optional complete OPTION3"}]},{"frameworkId":33,"frameworkName":"Multi Column Condition","frameworkType":"GENERIC_DATA_ROW","description":"This framework is used to mask columns with different algorithms based on the value of a \"key\" column. A JSON list of conditions enumerates the various keys and which algorithms should be assigned. Additional information is available in the 'Learn More' screen above.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":20,"name":"key","type":"STRING","isReadOnly":true,"isOptional":false,"description":"The key column (read only) defines the condition how the value columns are being masked."},{"fieldId":21,"name":"string1","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string1 (mandatory : false)"},{"fieldId":22,"name":"string2","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string2 (mandatory : false)"},{"fieldId":23,"name":"string3","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string3 (mandatory : false)"},{"fieldId":24,"name":"string4","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string4 (mandatory : false)"},{"fieldId":25,"name":"string5","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string5 (mandatory : false)"},{"fieldId":26,"name":"string6","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string6 (mandatory : false)"},{"fieldId":27,"name":"string7","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string7 (mandatory : false)"},{"fieldId":28,"name":"string8","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string8 (mandatory : false)"},{"fieldId":29,"name":"string9","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string9 (mandatory : false)"},{"fieldId":30,"name":"string10","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Masked field: string10 (mandatory : false)"},{"fieldId":31,"name":"concat1","type":"STRING","isReadOnly":false,"isOptional":true,"description":"Concatenated field (mandatory : false)"},{"fieldId":32,"name":"numeric1","type":"BIG_DECIMAL","isReadOnly":false,"isOptional":true,"description":"Masked field: numeric1 (mandatory : false)"},{"fieldId":33,"name":"numeric2","type":"BIG_DECIMAL","isReadOnly":false,"isOptional":true,"description":"Masked field: numeric2 (mandatory : false)"},{"fieldId":34,"name":"numeric3","type":"BIG_DECIMAL","isReadOnly":false,"isOptional":true,"description":"Masked field: numeric3 (mandatory : false)"},{"fieldId":35,"name":"date1","type":"LOCAL_DATE_TIME","isReadOnly":false,"isOptional":true,"description":"Masked field: date1 (mandatory : false)"},{"fieldId":36,"name":"date2","type":"LOCAL_DATE_TIME","isReadOnly":false,"isOptional":true,"description":"Masked field: date2 (mandatory : false)"},{"fieldId":37,"name":"date3","type":"LOCAL_DATE_TIME","isReadOnly":false,"isOptional":true,"description":"Masked field: date3 (mandatory : false)"},{"fieldId":38,"name":"binary1","type":"BYTE_BUFFER","isReadOnly":false,"isOptional":true,"description":"Masked field: binary1 (mandatory : false)"},{"fieldId":39,"name":"binary2","type":"BYTE_BUFFER","isReadOnly":false,"isOptional":true,"description":"Masked field: binary2 (mandatory : false)"},{"fieldId":40,"name":"binary3","type":"BYTE_BUFFER","isReadOnly":false,"isOptional":true,"description":"Masked field: binary3 (mandatory : false)"}]},{"frameworkId":32,"frameworkName":"Name","frameworkType":"STRING","description":"This Name algorithm masks input name (first or last) using values from the supplied LookupFile","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":20,"frameworkName":"Numeric Expression","frameworkType":"BIG_DECIMAL","description":"Numeric Expression masks input by evaluating it within a one-line, user-defined expression, which must be a valid Java expression that returns a java.math.BigDecimal object or another object that can be converted into a BigDecimal. The expression can reference user-defined constant variables that remain fixed for the life of the algorithm, as well as a special long integer \"seed\" constant whose value is based on the algorithm key.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":24,"frameworkName":"Payment Card","frameworkType":"STRING","description":"This Payment Card algorithm masks payment card values by mapping all characters in the character group [0-9] to another character within the group. The last digit of the input may remain the same if the calculated check digit is equivalent to the last digit of the input. All characters outside of this character group remain unmasked. The masked result is deterministic for each input under the same algorithm key. Any inputs with more than one digit will never mask to the original value.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":18,"frameworkName":"Regex Decompose","frameworkType":"STRING","description":"This algorithm masks by comparing the input value to one or more regular expression patterns, applying the list of actions associated with the first matching pattern to the input. A regex and its associated list of actions is represented by the MaskPattern object. If the regular expression contains capturing groups, the action list should contain an action for each group, otherwise, there should be exactly one action. The regular expression syntax supported is defined by the Java 8 class java.util.regex.Pattern. A fallback action may be defined; this action applies when none of the defined patterns match an input.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":21,"frameworkName":"Secure Lookup","frameworkType":"STRING","description":"This Secure Lookup algorithm masks by selecting a stable replacement value from provided Lookup File:\n1. All leading and trailing whitespace is preserved and ignored during hash calculation.\n   Values that are entirely whitespace are not masked.\n2. If input case is to be preserved, input is classified as: all upper, all lower, or mixed.\n3. Check the `inputCaseSensitive` flag. If set to FALSE - lowercase the input prior to calculating the hashed value.\n4. Look up the replacement value in the lookupFile using an index based on the hash of the input value.\n5. Adjust the character case of the replacement value based on the classification in step #2.\n   If case was classified as mixed or the PRESERVE_LOOKUP_FILE cases option is chosen, the replacement is used unmodified.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":16,"frameworkName":"Segment Mapping","frameworkType":"STRING","description":"The Segment Mapping Algorithm allows for masking of a string on a per-segment basis. A string can be subdivided into many segments, which can then define their masking behavior (MASK_ALPHANUMERIC, MASK_NUMERIC, PRESERVE, or CONSTANT). The input and masked value ranges are customizable. All masking values for a specific instance of this algorithm are deterministic.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":26,"frameworkName":"String Algorithm Chain","frameworkType":"STRING","description":"Creates a chain of string algorithms that will consecutively be applied to an input value.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":35,"frameworkName":"Telefone","frameworkType":"STRING","description":"Algoritmo para mascaramento CM:Numeric de Telefones armazenados em colunas únicas","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"}},{"frameworkId":39,"frameworkName":"TelefoneMC","frameworkType":"GENERIC_DATA_ROW","description":"Algoritmo para mascaramento CM:Numeric de Telefones armazenados  em 3 colunas:ddi, ddd, telefone","plugin":{"pluginId":14,"pluginName":"BR","pluginAuthor":"Delphix Corp","pluginType":"EXTENDED_ALGORITHM"},"fields":[{"fieldId":46,"name":"codigoArea","type":"STRING","isReadOnly":false,"isOptional":false},{"fieldId":47,"name":"numeroTelefone","type":"STRING","isReadOnly":false,"isOptional":false},{"fieldId":48,"name":"codigoPais","type":"STRING","isReadOnly":false,"isOptional":false}]},{"frameworkId":28,"frameworkName":"Tokenization","frameworkType":"STRING","description":"The Tokenization framework allows users to mask and re-identify data. By default, this is an algorithm used with Tokenization/Re-Identification, though it can also be used as a Masking algorithm. AES-128 in CBC-CTS mode is used to encrypt values. The result is an alphanumeric string that is longer than the original value. If the encrypted value is too long to fit in the column, a fallback reversible masking algorithm may be selected to be used, or the job will fail.","plugin":{"pluginId":7,"pluginName":"dlpx-core","pluginAuthor":"Delphix Engineering","pluginType":"EXTENDED_ALGORITHM"}}]}